Объекты и классы

В Python объекты — это значения, создаваемые на основе шаблона — класса. Программист описывает с помощью специального синтаксиса содержимое класса и потом во время исполнения создает объекты — экземпляры (instances) этого класса. 
У класса есть свои данные — атрибуты класса. К ним имеют доступ все экземпляры класса. 
При этом экземпляры имеют свои атрибуты — атрибуты экземпляра. Эти данные доступны только объекту.

Технически в Python любой объект может получить доступ к содержимому любого другого объекта, если имеет ссылку на него. Но на уровне добровольных соглашений такой доступ можно ограничивать.

Некоторые атрибуты могут быть функциями. В этом случае такие атрибуты называют методами. Вы уже пользовались методами списков и словарей, так что некоторое представление о методах у вас имеется!

Инкапсуляция — это упаковывание данных и поведения (процедур, работающих с данными) в один объект. Инкапсуляция преследует все ту же цель — сокрытие сложности за абстракцией. 


Полиморфизм ("многообразие форм" по-гречески) позволяет смотреть на разные объекты так, чтобы с определенной точки зрения они были похожи. Под похожестью здесь мы подразумеваем одинаковое поведение, то есть возможность выполнить одни и те же действия.

Так вот, код, который работает с разными объектами без точного знания того, с чем он работает в данный момент, и использующий только лишь их (объектов) общие свойства, называется полиморфным. А возможность писать такой код — и есть полиморфизм.

Как вы можете уже догадаться, полиморфизм тоже связан с абстракцией: полиморфному коду достаточно знать об объектах только важные ему сведения, от остального знания код абстрагируется!


Наследование — свойство объектной модели устанавливать связь между классами так, что классы-потомки получают (наследуют) те же свойства и поведение, которыми обладают классы-предки. во всех случаях мы опять же получаем инструмент для абстрагирования: если мы знаем, что некий класс реализует нужное нам поведение, то мы можем предполагать, что и все его потомки, в том числе и непрямые, будут этим поведением обладать

---
Пространство имен (namespace), это некая совокупность этих имен, в пределах которой каждое имя уникально. При этом разные пространства имен могут содержать одно и то же имя, но в разных пространствах это имя может быть связано с разными сущностями.

Каждый класс также является отдельным пространством имен — имен атрибутов класса. Атрибут, это то же самое определение. В момент определения класса определяются и его атрибуты.

```python
class Color:
    red = rgb(255, 0, 0)
    green = rgb(0, 255, 0)
    blue = rgb(0, 0, 255)
```

------

Модули и классы в Python являются пространствами имен. И эти пространства имен открыты для изменения

Не используйте изменяемые объекты-одиночки, каковыми являются большинство классов и все модули! Исключения возможны, но они обычно предполагают, что вы знаете, что делаете, и готовы к последствиям.

Одиночка или singleton — название приема, который позволяет во всех местах программы работать с неким объектом, который всегда существует в единственном экземпляре, но при этом объект не передается явно между местами в коде, которые его используют. Пример одиночки: объект, хранящий конфигурацию программы. Она загружается из внешнего источника (например, файла) при первом обращении к объекту, а затем все последующие обращения к конфигурации сразу же получают доступ к уже загруженному объекту.

Вы могли слышать, что пользоваться глобальными переменными плохо. Так говорят именно из-за того, что очень сложно следить за изменениями в одном месте кода и предсказывать влияние этих изменений на остальные части программы. Так вот, изменяемые (и добавляемые) атрибуты классов и модулей — это те самые глобальные переменные!

Кому-то эти возможности могут показаться очень удобными, но не нужно заблуждаться: кажущееся удобство практически всегда приводит к тому, что вы тратите много времени на поиск мест, которые внесли подобные изменения, и что-то в итоге сломалось. Ошибиться очень легко, а затронута будет большая часть программы. Ведь изменения, вносимые в класс, влияют на все экземпляры этого класса — не только на будущие, но и на уже созданные!

---
Класс, как мы уже увидели, может хранить данные. Но типичный класс присутствует в программе в единственном экземпляре. Поэтому сам по себе класс не очень полезен, ведь хранить определения можно и в модулях. Весь смысл использования классов заключается в их инстанцировании.

Инстанцированием (instantiation) называют процесс (акт) создания на основе класса экземпляра (instance) — такого объекта, который получает доступ ко всему содержимому класса, но при этом обладает и способностью хранить собственные данные. При этом, имея объект, всегда можно узнать, экземпляром какого класса он является.

все экземпляры являются отдельными объектами, поэтому оператор is дает False как при соотнесении экземпляров между собой, так и при соотнесении любого экземпляра с объектом класса (bob, alice и Person — три самостоятельных объекта).

Атрибут __dict__
Стоит прямо сейчас заглянуть "под капот" объектной системы Python, чтобы вы в дальнейшем могли исследовать объекты самостоятельно. Это и интересно, и полезно — как при обучении, так и при отладке объектного кода.

Итак, внутри каждого объекта Python хранит… словарь! Имена атрибутов в пространствах имен выступают ключами этого словаря, а значения являются ссылками на другие объекты. Словарь этот всегда называется __dict__ и тоже является атрибутом. Обращаясь к этому словарю, вы можете получить доступ к значениям атрибутов

машинерия объектной системы Python при обращении к атрибуту сначала ищет атрибут в словаре экземпляра. Но если там соответствующего ключа не нашлось, то атрибут ищется уже в классе.

Python мог бы копировать словарь класса при инстанцировании. Но это привело бы к излишнему потреблению памяти. А вот "коллективное использование", напротив, позволяет память экономить!

И, конечно же, словарь __dict__ объекта может быть изменен через модификацию __dict__: даже если изначально у класса не было такого атрибута

Выше мы уже упоминали, что объект всегда связан с классом. Эта связь заключается в наличии у экземпляра атрибута __class__, который является ссылкой на объект класса


рекомендуемый способ проверки принадлежности к классу выглядит так:

isinstance()

------


Имена атрибутов класса могут указывать на функции. Такие функции называются методами

Методы нужны для того, чтобы работать с данными объектов класса. Но для этого методы должны быть связаны (bound).

Foo.bar — это не связанный метод, то есть обычная функция. А вот x.bar уже связан ("bound") с объектом x


Но как метод получает доступ к связанному объекту, спросите вы? В Python методы получают ссылку на связанный объект в качестве первого аргумента. А называть этот аргумент принято именем "self".

------


Метод __init__

Этот метод отвечает за инициализацию экземпляров класса после их создания.

Заполнение атрибутов объекта после его создания выглядит громоздко и может приводить к разного рода ошибкам: объект может какое-то время находиться в "недозаполненном" (более общее название — "неконсистентном") состоянии. Инициализатор же позволяет получить уже полностью настроенный экземпляр.

class Person:
    def __init__(self, name):
        self.name = name


Вы заметили, что Python сам вызывает метод __init__ в нужный момент? Это же касается большинства dunder-методов: таковые вы только объявляете, но вручную не вызываете. Такое поведение часто называют протоколом (или поведением): класс реализует некий протокол, предоставляя нужные dunder-методы. А Python, в свою очередь, работает с объектом посредством протокола.

class Person:
    def __init__(self, name):
        self.name = name
    def __len__(self):
        return len(self.name)

tom = Person('Thomas')
len(tom)

Вызов функции len на самом деле приводит к вызову метода __len__ у переданного в аргументе объекта

Протоколы и "утиная типизация"
Существует такой термин: "утиная типизация" ("duck typing") — "Если что-то крякает как утка и плавает как утка, то возможно это утка и есть!". Данный термин, пусть и звучит как шутка, описывает важный принцип построения абстракций: коду практически всегда достаточно знать о значении, с которым этот код работает, что это значение обладает нужными свойствами. Все остальное — не существенно.

Если коду достаточно знать, что сущность умеет плавать и крякать, то код не должен проверять сущность на фактическую принадлежность к уткам. Это позволит коду работать с робо-утками, даже если все настоящие утки вымрут, ведь код работает с абстрактными утками!

Протоколы в Python являются представлением идеи утиной типизации в коде. Так циклу for незачем знать, что за источник он обходит, лишь бы источник поддерживал протокол итерации. Так и вы, когда возникает желание узнать о значении, уж не список ли это, всегда проверяйте себя: возможно вашему коду не нужно знать, что значение является списком!

Протоколов в Python существует великое множество. Вы можете заставить объекты вашего класса вести себя подобно словарям и спискам (bob['key'] и bob[-1]), походить на функции (bob(42, foo=True)), уметь "складываться и умножаться" (bob + alice). И Python будет обращаться с объектами соответствующим образом, ведь он тоже всегда следует протоколам — несмотря на то, что уж интерпретатору-то всегда известно, что за объект вы ему подсунули!

Протокол -  договоренность между стороной, ожидающей наличия некоторых методов у объекта, и классом, предоставляющим эти методы

------

В Python все классы наследуются от object. Механизм поиска атрибутов работают следующим образом: идет поиск метода в классе, если он не был обнаружен поиск переходит в родительский и так далее. Объект класса инициализируются с помощью вызова метода __new__() - который возвращает объект класса и метода __init__() - который инициализирует атрибуты экземпляра класса. Когда мы засовываем в класс __init__, __new__, __add__ и т.д. мы по сути переопределяем методы класса object, интерпретатор находит их в нашем классе и не ищет их в родительском классе object

Это называется перегрузкой операций, дает представление о том, как устроено все под капотом, фактически операция 2 + 3, представляет собой вызов dunder метода object.__add__(2, 3) С помощью перегрузки операций мы по сути можем строить структуры данных, обладающие отличающимся поведением. Переопределив __new__ мы можем допустим создавать подкласс встроенных типов, к примеру string и т.д

------



