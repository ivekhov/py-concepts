# Объекты и классы

В Python объекты — это значения, создаваемые на основе шаблона — класса. Программист описывает с помощью специального синтаксиса содержимое класса и потом во время исполнения создает объекты — экземпляры (instances) этого класса. 
У класса есть свои данные — атрибуты класса. К ним имеют доступ все экземпляры класса. 
При этом экземпляры имеют свои атрибуты — атрибуты экземпляра. Эти данные доступны только объекту.

Технически в Python любой объект может получить доступ к содержимому любого другого объекта, если имеет ссылку на него. Но на уровне добровольных соглашений такой доступ можно ограничивать.

Некоторые атрибуты могут быть функциями. В этом случае такие атрибуты называют методами. Вы уже пользовались методами списков и словарей, так что некоторое представление о методах у вас имеется!

Инкапсуляция — это упаковывание данных и поведения (процедур, работающих с данными) в один объект. Инкапсуляция преследует все ту же цель — сокрытие сложности за абстракцией. 


## Полиморфизм 
("многообразие форм" по-гречески) позволяет смотреть на разные объекты так, чтобы с определенной точки зрения они были похожи. Под похожестью здесь мы подразумеваем одинаковое поведение, то есть возможность выполнить одни и те же действия.

Так вот, код, который работает с разными объектами без точного знания того, с чем он работает в данный момент, и использующий только лишь их (объектов) общие свойства, называется полиморфным. А возможность писать такой код — и есть полиморфизм.

Как вы можете уже догадаться, полиморфизм тоже связан с абстракцией: полиморфному коду достаточно знать об объектах только важные ему сведения, от остального знания код абстрагируется!


## Наследование 
свойство объектной модели устанавливать связь между классами так, что классы-потомки получают (наследуют) те же свойства и поведение, которыми обладают классы-предки. во всех случаях мы опять же получаем инструмент для абстрагирования: если мы знаем, что некий класс реализует нужное нам поведение, то мы можем предполагать, что и все его потомки, в том числе и непрямые, будут этим поведением обладать

---
Пространство имен (namespace), это некая совокупность этих имен, в пределах которой каждое имя уникально. При этом разные пространства имен могут содержать одно и то же имя, но в разных пространствах это имя может быть связано с разными сущностями.

Каждый класс также является отдельным пространством имен — имен атрибутов класса. Атрибут, это то же самое определение. В момент определения класса определяются и его атрибуты.

```python
class Color:
    red = rgb(255, 0, 0)
    green = rgb(0, 255, 0)
    blue = rgb(0, 0, 255)
```

------

Модули и классы в Python являются пространствами имен. И эти пространства имен открыты для изменения

Не используйте изменяемые объекты-одиночки, каковыми являются большинство классов и все модули! Исключения возможны, но они обычно предполагают, что вы знаете, что делаете, и готовы к последствиям.

## Одиночка или singleton 
название приема, который позволяет во всех местах программы работать с неким объектом, который всегда существует в единственном экземпляре, но при этом объект не передается явно между местами в коде, которые его используют. Пример одиночки: объект, хранящий конфигурацию программы. Она загружается из внешнего источника (например, файла) при первом обращении к объекту, а затем все последующие обращения к конфигурации сразу же получают доступ к уже загруженному объекту.

Вы могли слышать, что пользоваться глобальными переменными плохо. Так говорят именно из-за того, что очень сложно следить за изменениями в одном месте кода и предсказывать влияние этих изменений на остальные части программы. Так вот, изменяемые (и добавляемые) атрибуты классов и модулей — это те самые глобальные переменные!

Кому-то эти возможности могут показаться очень удобными, но не нужно заблуждаться: кажущееся удобство практически всегда приводит к тому, что вы тратите много времени на поиск мест, которые внесли подобные изменения, и что-то в итоге сломалось. Ошибиться очень легко, а затронута будет большая часть программы. Ведь изменения, вносимые в класс, влияют на все экземпляры этого класса — не только на будущие, но и на уже созданные!

---
Класс, как мы уже увидели, может хранить данные. Но типичный класс присутствует в программе в единственном экземпляре. Поэтому сам по себе класс не очень полезен, ведь хранить определения можно и в модулях. Весь смысл использования классов заключается в их инстанцировании.

Инстанцированием (instantiation) называют процесс (акт) создания на основе класса экземпляра (instance) — такого объекта, который получает доступ ко всему содержимому класса, но при этом обладает и способностью хранить собственные данные. При этом, имея объект, всегда можно узнать, экземпляром какого класса он является.

все экземпляры являются отдельными объектами, поэтому оператор is дает False как при соотнесении экземпляров между собой, так и при соотнесении любого экземпляра с объектом класса (bob, alice и Person — три самостоятельных объекта).

## Атрибут __dict__
Стоит прямо сейчас заглянуть "под капот" объектной системы Python, чтобы вы в дальнейшем могли исследовать объекты самостоятельно. Это и интересно, и полезно — как при обучении, так и при отладке объектного кода.

Итак, внутри каждого объекта Python хранит… словарь! Имена атрибутов в пространствах имен выступают ключами этого словаря, а значения являются ссылками на другие объекты. Словарь этот всегда называется __dict__ и тоже является атрибутом. Обращаясь к этому словарю, вы можете получить доступ к значениям атрибутов

машинерия объектной системы Python при обращении к атрибуту сначала ищет атрибут в словаре экземпляра. Но если там соответствующего ключа не нашлось, то атрибут ищется уже в классе.

Python мог бы копировать словарь класса при инстанцировании. Но это привело бы к излишнему потреблению памяти. А вот "коллективное использование", напротив, позволяет память экономить!

И, конечно же, словарь __dict__ объекта может быть изменен через модификацию __dict__: даже если изначально у класса не было такого атрибута

Выше мы уже упоминали, что объект всегда связан с классом. Эта связь заключается в наличии у экземпляра атрибута __class__, который является ссылкой на объект класса


рекомендуемый способ проверки принадлежности к классу выглядит так:

isinstance()

------


Имена атрибутов класса могут указывать на функции. Такие функции называются методами

Методы нужны для того, чтобы работать с данными объектов класса. Но для этого методы должны быть связаны (bound).

Foo.bar — это не связанный метод, то есть обычная функция. А вот x.bar уже связан ("bound") с объектом x


Но как метод получает доступ к связанному объекту, спросите вы? В Python методы получают ссылку на связанный объект в качестве первого аргумента. А называть этот аргумент принято именем "self".

------


## Метод __init__

Этот метод отвечает за инициализацию экземпляров класса после их создания.

Заполнение атрибутов объекта после его создания выглядит громоздко и может приводить к разного рода ошибкам: объект может какое-то время находиться в "недозаполненном" (более общее название — "неконсистентном") состоянии. Инициализатор же позволяет получить уже полностью настроенный экземпляр.

class Person:
    def __init__(self, name):
        self.name = name


Вы заметили, что Python сам вызывает метод __init__ в нужный момент? Это же касается большинства dunder-методов: таковые вы только объявляете, но вручную не вызываете. Такое поведение часто называют протоколом (или поведением): класс реализует некий протокол, предоставляя нужные dunder-методы. А Python, в свою очередь, работает с объектом посредством протокола.

class Person:
    def __init__(self, name):
        self.name = name
    def __len__(self):
        return len(self.name)

tom = Person('Thomas')
len(tom)

Вызов функции len на самом деле приводит к вызову метода __len__ у переданного в аргументе объекта

## Протоколы и "утиная типизация"
Существует такой термин: "утиная типизация" ("duck typing") — "Если что-то крякает как утка и плавает как утка, то возможно это утка и есть!". Данный термин, пусть и звучит как шутка, описывает важный принцип построения абстракций: коду практически всегда достаточно знать о значении, с которым этот код работает, что это значение обладает нужными свойствами. Все остальное — не существенно.

Если коду достаточно знать, что сущность умеет плавать и крякать, то код не должен проверять сущность на фактическую принадлежность к уткам. Это позволит коду работать с робо-утками, даже если все настоящие утки вымрут, ведь код работает с абстрактными утками!

Протоколы в Python являются представлением идеи утиной типизации в коде. Так циклу for незачем знать, что за источник он обходит, лишь бы источник поддерживал протокол итерации. Так и вы, когда возникает желание узнать о значении, уж не список ли это, всегда проверяйте себя: возможно вашему коду не нужно знать, что значение является списком!

Протоколов в Python существует великое множество. Вы можете заставить объекты вашего класса вести себя подобно словарям и спискам (bob['key'] и bob[-1]), походить на функции (bob(42, foo=True)), уметь "складываться и умножаться" (bob + alice). И Python будет обращаться с объектами соответствующим образом, ведь он тоже всегда следует протоколам — несмотря на то, что уж интерпретатору-то всегда известно, что за объект вы ему подсунули!

Протокол -  договоренность между стороной, ожидающей наличия некоторых методов у объекта, и классом, предоставляющим эти методы

------

В Python все классы наследуются от object. Механизм поиска атрибутов работают следующим образом: идет поиск метода в классе, если он не был обнаружен поиск переходит в родительский и так далее. Объект класса инициализируются с помощью вызова метода __new__() - который возвращает объект класса и метода __init__() - который инициализирует атрибуты экземпляра класса. Когда мы засовываем в класс __init__, __new__, __add__ и т.д. мы по сути переопределяем методы класса object, интерпретатор находит их в нашем классе и не ищет их в родительском классе object

Это называется перегрузкой операций, дает представление о том, как устроено все под капотом, фактически операция 2 + 3, представляет собой вызов dunder метода object.__add__(2, 3) С помощью перегрузки операций мы по сути можем строить структуры данных, обладающие отличающимся поведением. Переопределив __new__ мы можем допустим создавать подкласс встроенных типов, к примеру string и т.д

------

## Геттеры, сеттеры, делитеры


метод, возвращающий динамически вычисляемое значение, называется геттером (getter).
@property
    def full_name(self):
        return self.name + ' ' + self.surname

Чтобы иметь возможность присвоить значение свойству, нужно использовать сеттер (setter). Сеттер — это тоже метод, который принимает новое значение для атрибута и как-то его обрабатывает. Чтобы метод стал сеттером, его тоже нужно соответствующим образом декорировать

    @full_name.setter
    def full_name(self, new):
        self.name, self.surname = new.split(' ')

Кроме геттеров и сеттеров, в Python существует еще один важный метод для управления атрибутами классов — это делитеры (deleter). Этот метод предоставляет дополнительный уровень контроля над тем, как атрибуты класса удаляются.

Делитер — это особый метод в классе, который вызывается при удалении атрибута. Как правило, удаление атрибута - это нечастая операция, и в большинстве случаев мы можем обойтись без явного определения делитера. Тем не менее, зная о его существовании, мы можем контролировать процесс удаления атрибутов, например, очищать связанные ресурсы или выполнять некоторую логику очистки.

    @full_name.deleter
    def full_name(self):
        print("Удаляем имя и фамилию!")
        self.name = None
        self.surname = None


## Наследование

Когда один класс становится наследником другого, то все атрибуты класса-предка (надкласса, superclass) становятся доступны классу-потомку (подклассу, subclass) — наследуются (достаются в наследство).

Наследование позволяет выделить общее для нескольких классов поведение и вынести его в отдельную сущность. То есть наследование является средством переиспользования кода (code reuse) — использования существующего кода для решения новых задач!

Наследование позволяет получить новый класс, немного отличающийся от старого. При этом нам не нужно иметь доступ к коду исходного класса, а значит с помощью наследования мы можем адаптировать (использовать повторно) под наши задачи, в том числе и чужие классы!

Здесь вы можете увидеть сходство с взаимоотношениями между классом и его экземпляром: если экземпляр получает свой собственный атрибут, то этот атрибут заменяет атрибут класса. Точно так же объявления в классе-потомке заменяют собой атрибуты класса-предка, если имя используется то же самое — говорят, переопределяют (override).

И, как и в случае с объектом, который может использовать все содержимое класса и заменять только небольшую часть атрибутов (или добавлять новые!), так и потомок по умолчанию получает все атрибуты предка, часть из которых может изменить.

## super()
https://ru.hexlet.io/courses/python-oop-basics/lessons/inheritance/theory_unit

внутри метода потомка нужно получить доступ к методу предка. Методу с тем же именем

Вызов super здесь заменяет обращение к self. При этом вы фактически обращаетесь к "памяти предков": получаете ссылку на атрибут предка. Более того, в данном случае, super().inc - это связанный с текущим экземпляром метод, то есть полноценная "оригинальная версия" из класса-предка.

Вызов super вместо явного вызова предка хорош не только тем, что автоматически связывает методы. При смене предка (такое бывает) в описании класса super учтет изменения, и вы получите доступ к поведению нового предка

super работает не только с методами, но и с атрибутами классов

Важно помнить, что super работает именно с классами. Вы не сможете получить доступ к атрибутам, которые добавляются в объект уже после того, как тот будет создан.


При наследовании классов часто возникает необходимость не только добавить новые атрибуты или методы, но и расширить или изменить инициализацию объекта. В этом случае очень важно корректно вызвать конструктор суперкласса, чтобы все атрибуты и состояние, которые должны быть наследованы, были правильно установлены.

Использование super() в __init__ позволяет нам вызвать конструктор суперкласса, что гарантирует, что весь необходимый код инициализации будет выполнен

def __init__(self):
        super().__init__()  # Вызываем конструктор предка

## Исключения и их обработка

Возбуждение (raising) исключения в коде похоже на return, только на его глобальную версию, завершающую все функции в порядке, обратном тому, в котором они вызывались. Если исключение будет возбуждено, но не будет перехвачено, то есть как-то обработано, вся программа так и завершится и вы увидите распечатку трейсбэка (traceback). Там-то и будет отображена та самая ошибка IndexError (или какая-то другая).

Иерархия исключений представляет собой дерево, корнем которого является BaseException, стволом — Exception, а дальше происходит ветвление на виды исключений, а затем — на конкретные исключения.

Зачем же нужно было придумывать эту самую иерархию исключений? Чтобы можно было "ловить" исключения как по одному (ловить IndexError), так и перехватывать целые группы (OSError).

У isinstance есть функция-близнец issubclass. Эта проверяет родство классов

Вот так выглядит возбуждение исключения:
raise ValueError('Age too low!')

Ключевое слово raise принимает в качестве аргумента экземпляр какого-либо класса, являющегося потомком BaseException. Большинство исключений принимают в качестве параметра строковое сообщение, описывающее конкретную ситуацию.

А так выглядит перехват исключений:

l = []
try:
    l[100500] = 42
except IndexError:
    print('Catched!')

# => Catched!


try: начинает блок, при выполнении которого могут возникать исключения. Следом идут одна или несколько веток except, которые описывают базовый класс исключений, которые будут перехватываться. Если возникшее исключение подошло — класс исключения оказался потомком от указанного базового класса или самим указанным классом, то будет выполнен код обработчика. В данном примере вместо ошибки мы видим печать сообщения.

Важно помнить, что если у вас указано несколько веток except, то первыми нужно указывать наиболее конкретные ветки

Ветка finally
Иногда не нужно отлавливать исключения в конкретном блоке кода. Например, вы хотите поймать исключение где-то выше или вообще ничего не ловить. Однако просто так прерывать выполнение кода нельзя, потому что требуется некое действие вроде закрытия открытого файла. В таких случаях применяют ветку finally

Код в finally выполнится в любом случае, вне зависимости от того, произошла ошибка или нет. Если ошибка все же произошла, то сразу после блока finally выполнение кода будет прервано и исключение "всплывет" выше

Ветка finally может использоваться вместе с ветками except, но должна идти самой последней.


Получение экземпляра исключения и возбуждение уже пойманного

Часто вы хотите получить доступ к сообщению исключения или каким-то дополнительным данным: более специфичные для предметной области исключения могут иметь специальные атрибуты, полезные при отладке. Для этого нужно указать в ветке except имя переменной, которая получит ссылку на экземпляр исключения:

try:
    ...
except (SQLSelectError, SQLInsertError) as e:
    print(f"Query execution error: '{e.query}'")
except DBConnectionError as e:
    print(f"Can't connect to DB: '{e.status}'")
...



Но что делать, если вы перехватили исключение, сделали некие необходимые действия, а затем решили "пробросить" исключение выше. Большинству новичков приходит на ум строчка raise e. Но это плохая идея: так вы получите возбуждение нового исключения, пусть даже и представляющего старый объект, а значит в traceback местом возникновения исключения будет уже эта самая строчка raise e! Обычно вы не хотите терять информацию о месте возникновения изначальной исключительной ситуации, поэтому просто пишите raise — так будет заново возбуждено последнее перехваченное исключение!



Антипаттерны при перехвате исключений
Перехватывать исключения можно неправильно. Неправильный порядок обработчиков мы уже обсуждали выше. Есть и другая типичная ошибка, которую, к счастью, обычно находит линтер: except Exception: (или просто except:). Чем же плох такой способ поймать сразу все исключения? Тем, что можно случайно поймать то, что ловить совсем даже не нужно



Совет: всегда перехватывайте только те исключения, которые ожидаете и собираетесь обработать именно в месте перехвата, а все остальные исключения пусть "всплывают" выше!

Единственный случай, в котором допустимо перехватывать Exception, это случай, когда в конце обработчика исключение возбуждается заново. Таким способом вы можете, например, протоколировать (логировать, записывать в log-файл) все ошибки, но никак их не обрабатывать, чтобы у вызывающей стороны была возможность отреагировать на ошибку.

Еще один антипаттерн: огромные try-блоки. Очень редко встречается действительно большой участок кода, в котором могут произойти всего несколько ожидаемых исключений. Практически всегда лучше перехватывать конкретные исключения в небольших участках кода, а в других участках не перехватывать ничего. Так вы не окажетесь в режиме "защитного программирования", когда все исключения всегда ловятся максимально рано, из-за чего код становится очень сложно читать.

Совет: перехватывайте только те ошибки, обработка которых позволит продолжить выполнение текущего участка кода!

https://docs.python.org/3/library/exceptions.html#exception-hierarchy 





