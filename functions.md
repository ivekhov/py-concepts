## Детерминированные функции


Детерминированная функция возвращает
- один и тот же результат
- для одинаковых входных параметров.

Например, детерминированной можно назвать функцию, которая считает количество символов


недетерминированные функции
Обратный случай — недетерминированные функции. Например, к этой категории относится функция, которая возвращает случайное число: у одного и того же входа мы получим всегда разный результат. Если хотя бы один из миллиона вызовов функции вернет другой результат, она считается недетерминированной

В этом случае невозможно построить однозначную таблицу значений функции; для таких функций таблицы значений выглядят как список (может быть, бесконечный) возможных значений, которые функция принимает на заданном наборе входных параметров.



Детерминированность — это важное свойство функции, так как она влияет на многие аспекты. Например, детерминированные функции удобны в работе — их легко оптимизировать и тестировать. Если возможно, то лучше сделать функцию детерминированной.

Побочные эффекты

Она вызывает побочный эффект — из-за выполнения функции запускается действие, которое изменяет среду выполнения. Еще побочные эффекты вызывают любые сетевые взаимодействия, чтение и запись файлов, вывод информации на экран и печать на принтере.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы: например, записать в базу, вывести на экран и отправить по сети.

Побочными эффектами print() отличается от других функций, которые также принимают на вход данные любого типа. Другие функции возвращают значения, которые можно дальше использовать. В отличие от них, функция print() выводит такой результат, с которым ничего нельзя сделать. Вывод на экран и возврат значения из функции — разные и независимые операции.


Обычно функции, обладающие побочными эффектами, не являются детерминированными, поэтому функции без побочных эффектов, детерминированные функции и чистые функции иногда путают. В действительности это разные свойства функций. Например, функция rand, которая возвращает случайное число, или гипотетическая функция GetGlobalVarX, которая возвращает значение глобальной переменной X (и больше ничего не делает), не являются детерминированными, хотя они и не обладают побочными эффектами. А вот гипотетическая функция print, выводящая текст на экран и всегда возвращающая 0, наоборот — является детерминированной, но обладает побочным эффектом (вывод текста на экран). Ни одна из них не является чистой.

Параметры функции

Необязательные 
max(arg1, arg2, *args[, key])


Аргументы — это данные, которые передаются в вызов функции

Есть две причины использовать именованные аргументы:
Они повышают читаемость, так как сразу видно имена
Можно не указывать все промежуточные параметры, которые нам сейчас не нужны
Именованные аргументы можно передавать одновременно с позиционными. Тогда позиционные должны идти в самом начале:

Аннотация типов

Включая тип результата функции по мере ее исполнения 
…
result: str = 
…


Аргументы 
Функции, детерминированные, чистые

Необязательный аргумент передается в квадратных скобках

func(x, y [, z])

--


функции с неограниченным количеством аргументов 

func(*args) 
оператор * упаковывает все передаваемые в функцию аргументы от текущей позиции и до конца в переменную как кортеж

Аргумент с оператором * забирает в себя все переданные значения. Если мы хотим использовать дополнительные аргументы, их нужно указать перед аргументом с оператором * 

Среди разработчиков на Python принято называть упомянутый аргумент именно *args — от слова arguments


func(**kwargs) 

Для именованных аргументов с неопределенным количеством аргументов применяется такая упаковка аргументов

Позиционные аргументы можно получать в виде *args, причем в произвольном количестве. Для именованных аргументов тоже существует подобная возможность. Только они получаются в виде словаря, что позволяет сохранить имена аргументов в ключах

```python
def g(**kwargs):
    return kwargs

g(x=1, y=2, z=None)
# {'x': 1, 'y': 2, 'z': None}
```


*args всегда указывается перед **kwargs, иначе будет ошибка:

При объявлении функций можно комбинировать позиционные аргументы, значения по умолчанию, *args и **kwargs одновременно. При использовании обычных позиционных аргументов их следует добавлять в начало перед аргументом *args

Полный порядок аргументов
Согласно этому правилу у нас идет следующий порядок расстановки аргументов:
Обычные позиционные аргументы
Аргумент *args
Аргументы со значением по умолчанию
Аргумент **kwargs

```python

def f(x, y, *args, kx=None, ky=42, **kwargs):
    return (x, y, args, kx, ky, kwargs)

f(1, 2, 3, 4, kx='a', ky='b', kz='c')
# (1, 2, (3, 4), 'a', 'b', {'kz': 'c'})
```

Передача именованных аргументов с помощью словаря
Как и в случае позиционных аргументов, именованные можно передавать в функцию пачкой в виде словаря. Для этого перед словарем нужно поставить две звездочки. Пример:
```python

def coords(x, y):
    return (x, y)

coords(x=1, **{'y': 2})
# (1, 2)
```

Keyword-only аргументы

возможность пометить именованные аргументы функции так, чтобы вызывать функцию можно было только через передачу этих аргументов по именам. Такие аргументы называются keyword-only и их нельзя передать в функцию в виде позиционных. Выглядит функция с подобными аргументами так:

```python

def open_file(name, *, writable=False, binary=False):
    …

f1 = open_file('foo.txt', writable=True)
f2 = open_file('bar.bin', binary=True)
f3 = open_file('raw.dat', True, True)
# TypeError: open_file() takes 1 positional argument but 3 were given
```

Здесь * выступает разделителем — отделяет обычные аргументы от строго именованных. Такой разделитель можно использовать только один раз в одном определении. Еще его нельзя применять в функциях с *args. Но можно объявлять функции, у которых будут только строго именованные аргументы. Для этого нужно поставить звездочку в самом начале перечня аргументов.
Этот пример демонстрирует подход к описанию аргументов. Первый аргумент — имя файла, который будет открыт. Оно всегда присутствует и связано по смыслу с именем функции. Поэтому этот аргумент можно не именовать. А writable и binary — необязательные аргументы, которые получают значения True/False. Поэтому опции и объявлены так, что могут быть указаны только явно.
Когда мы используем keyword-only аргументы вместе с именованными аргументами (**kwargs), возникает проблема. Именованные аргументы могут перехватить значения, которые должны были быть переданы как keyword-only аргументы. В итоге это может привести к ошибкам в работе функции.

Упаковка и распаковка аргументов. 
В Python операторы * и ** используются, чтобы упаковывать и распаковывать итерабельные объекты и словари. Эти операторы обеспечивают гибкий способ обработки аргументов функций и позволяют писать функции, которые могут принимать переменное количество аргументов. В этом уроке мы узнаем, как пользоваться ими
Оператор * 
используется для упаковки и распаковки итерируемых объектов, таких как списки или кортежи. При использовании перед итерируемым объектом, во время вызова функции, оператор * распаковывает его. Элементы итерируемого объекта передаются в качестве аргумента функции
```python

def sum_of_values(a, b, c):
    return a + b + c


values = [1, 2, 3]
result = sum_of_values(*values)
```



Также оператор * можно использовать, чтобы упаковывать итерабельные переменные. Это позволяет присваивать их отдельным переменным:

```python
my_list = [1, 2, 3, 4]
a, b, *c = my_list
print(a, b, c)
# 1 2 [3, 4]
# Оператор * можно использовать для распаковки итерируемого списка в новый список или кортеж:
my_list = [1, 2, 3]
new_list = [*my_list, 4, 5, 6]
print(new_list)
# [1, 2, 3, 4, 5, 6]


my_tuple = (1, 2, 3)
new_tuple = (*my_tuple, 4, 5, 6)
print(new_tuple)
# (1, 2, 3, 4, 5, 6)
```
Оператор ** 
используется для упаковки и распаковки словарей. При использовании перед словарем во время вызова функции оператор ** распаковывает пары ключ-значение словаря в аргументы ключевых слов, которые могут быть переданы в функцию:
```python

def print_details(name, age):
    print(f"Name: {name}")
    print(f"Age: {age}")

details = {"name": "John", "age": 30}
print_details(**details)
# Name: John
# Age: 30
```


Оператор ** также можно использовать для создания словаря из последовательности пар ключ-значение:

```python

dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}

combined_dict = {**dict1, **dict2}

print(combined_dict)
# {"a": 1, "b": 2, "c": 3, "d": 4}
```
